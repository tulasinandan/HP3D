!================================================================================
!
!
!
!   This is the OTV wave initialization subroutine for the hybrid code.
!
!
!		Tulasi Nandan Parashar 09/20/2006
!
!
!
!================================================================================

#include "param"
#ifndef b0x
#define b0x 0.
#endif
#ifndef b0y
#define b0y 0.
#endif
#ifndef b0z
#define b0z 0.
#endif
#ifndef psi0
#define psi0 0.
#endif
#ifndef w0
#define w0 1.
#endif
#ifndef T_i
#define T_i 0.
#endif
#ifndef T_e
#define T_e 0.
#endif
#ifndef n_0
#define n_0 1.
#define no_background_density
#endif

Subroutine init_Turb()
  Use pe_env
  Use partfield
  Implicit None

  Real(kind=drk) gx,gy,gz,xx,yy,zz,b,n,rand_num,sech,ppert,npert
  Real(kind=drk), Parameter :: dx=lx/(nx*pex), dy=ly/(ny*pey), dz=lz/(nz*pez),&
                               pi2=6.2831853, pi4=2*pi2
  Integer :: i,x,y,z,pe,sign!,nsup
  Real(kind=drk) :: nsup 
!!!!!!! Turbulent initial conditions generated by Bill's code or the ones from
!!!!!!! Ron Ghosh
! Real(kind=drk), Dimension(0:nx+1,0:ny+1,0:nz+1) :: fbx, fby, fbz, fvx, fvy, &
!                                                    fvz
  Real(kind=drk), Dimension(0:nx+1,0:ny+1,0:nz+1) :: fbx, fby, fbz, fvx, fvy, &
                                                     fvz
  Real(kind=drk), Dimension(0:nx*pex+1,0:ny*pey+1,1:nz*pez) :: np 
  Real(kind=drk), Dimension(1:nx*pex,1:ny*pey) :: tmp
  integer :: ixx, iyy, nnnn
  Real(kind=drk) :: xm,xp,ym,yp,zm,zp,vix,viy,viz
! Tulasis parameters for OTV 09/20/2006
  Real(kind=drk) :: sum_ncell, ntot_p
  Integer :: mpi_err
  Integer :: part_counter
  gx(x)=((x-0.5)+my_pex*nx)*dx
  gy(y)=((y-0.5)+my_pey*ny)*dy
  gz(z)=((z-0.5)+my_pez*nz)*dz
  sech(yy)=1/cosh(yy)

  inquire(iolength=nnnn) tmp
! ppert(xx,yy)=0.

! npert(xx,yy)= ppert(xx,yy)/T_i
! nsup=int(1./(T_i+T_e)+8.)
  nsup=2.0

  call init_pe_env()
  if (nprocs .ne. n_pes .and. myproc == 0) then
    write(6,*) '***** init-hybrid: compiled for different number of PEs *****'
    call exitallpes()
  endif

!write parameters to log-file
  if (myproc==0) then
    write(6,*) '********** initTurb **********'
    write(6,*) '******* (hybrid version) *******'
    write(6,*) '********** parameters **********'
    write(6,*) '     grid points nx = ',nx
    write(6,*) '     grid points ny = ',ny
    write(6,*) '     grid points nz = ',nz
    write(6,*) '     processors pex = ',pex
    write(6,*) '     processors pey = ',pey
    write(6,*) '     processors pez = ',pez
    write(6,*) '     edge length lx = ',lx
    write(6,*) '     edge length ly = ',ly
    write(6,*) '     edge length lz = ',lz
    write(6,*) '     part./gridp. = ',ppg
    write(6,*) '     T_i = ',T_i
    write(6,*) '     T_e = ',T_e
#ifndef no_background_density
    write(6,*) '     n_0 = ',n_0
#else
    write(6,*) '     n_0 = 0'
#endif
    write(6,*) '     b0 = ',b0x, b0y, b0z
    write(6,*) '     w0 = ',w0
    write(6,*) '     psi0 = ',psi0
    write(6,*) '********** parameters **********'
  endif

! READ IN THE INITIAL CONDITIONS
    fbx=0.; fby=0.; fbz=0.
    fvx=0.; fvy=0.; fvz=0.
    np=0.

!   THIS IS FOR 2D INITIAL CONDITIONS THAT I GET FROM BILL'S CODE 
    ixx=my_pex*nx; iyy=my_pey*ny
    write(6,*) 'myproc, ixx, iyy',my_pex,my_pey,ixx,iyy

    open(unit=8,status='old',file='Fbx.dat',form='unformatted',access='direct',recl=nnnn)
    read(8,rec=1) tmp
    close(8)
    fbx(1:nx,1:ny,1) = tmp(ixx+1:ixx+nx,iyy+1:iyy+ny)

    open(unit=8,status='old',file='Fby.dat',form='unformatted',access='direct',recl=nnnn)
    read(8,rec=1) tmp
    close(8)
    fby(1:nx,1:ny,1) = tmp(ixx+1:ixx+nx,iyy+1:iyy+ny)

    open(unit=8,status='old',file='Fbz.dat',form='unformatted',access='direct',recl=nnnn)
    read(8,rec=1) tmp
    close(8)
    fbz(1:nx,1:ny,1) = tmp(ixx+1:ixx+nx,iyy+1:iyy+ny)

    open(unit=8,status='old',file='Fvx.dat',form='unformatted',access='direct',recl=nnnn)
    read(8,rec=1) tmp
    close(8)
    fvx(1:nx,1:ny,1) = tmp(ixx+1:ixx+nx,iyy+1:iyy+ny)

    open(unit=8,status='old',file='Fvy.dat',form='unformatted',access='direct',recl=nnnn)
    read(8,rec=1) tmp
    close(8)
    fvy(1:nx,1:ny,1) = tmp(ixx+1:ixx+nx,iyy+1:iyy+ny)

    open(unit=8,status='old',file='Fvz.dat',form='unformatted',access='direct',recl=nnnn)
    read(8,rec=1) tmp
    close(8)
    fvz(1:nx,1:ny,1) = tmp(ixx+1:ixx+nx,iyy+1:iyy+ny)

    open(unit=8,status='old',file='den.dat',form='unformatted',access='direct',recl=nnnn)
    read(8,rec=1) tmp
    close(8)
    np(1:nx*pex,1:ny*pey,1)=tmp-n_0
    np(0,:,1)=np(nx*pex,:,1) ; np(nx*pex+1,:,1)=np(1,:,1)
    np(:,0,1)=np(:,ny*pey,1) ; np(:,ny*pey+1,1)=np(:,1,1)

!! Only for one run
!  fbx=fbx/8.; fby=fby/8.; fbz=fbz/8.; fvx=fvx/8.; fvy=fvy/8.; fvz=fvz/8.


!for the boundary to be called correctly, make sure fvx and fvy is has three dependences (x,y,z)
   call boundary(0,0,fbx)
   call boundary(0,0,fby)
   call boundary(0,0,fbz)
   call boundary(0,0,fvx)
   call boundary(0,0,fvy)
   call boundary(0,0,fvz)

! set electric and magnetic field (no kinetic equilibrium with guide field bz)
  do z=1,nz; do y=1,ny; do x=1,nx
    b1x(x,y,z)=fbx(x,y,1); b1y(x,y,z)=fby(x,y,1); b1z(x,y,z)=fbz(x,y,1)
  enddo; enddo; enddo
   !call bound_b(b1x,b1y,b1z)


!-------------------------------------------
! finding the total number of particles
! Ntot_proc=n_avg*Sum(n_cell)/(pex*pey)
!	 		Tulasi
  ntot_p=0
  do x=1,nx; do y=1,ny; do z=1,nz
!   ntot_p = ntot_p + npert(gx(x),gy(y)) 
    ntot_p = ntot_p + np(x,y,z) 
  enddo; enddo; enddo
! ntot_p = nz*ntot_p
  
  call MPI_Allreduce(ntot_p,sum_ncell,1,mpi_drk,MPI_SUM,MPI_COMM_WORLD,mpi_err)
  n_avg=ppg/n_0 
!  write(6,*) ''
!  write(6,*) 'processor=',myproc,'pert=',ntot_p
!  write(6,*) 'total=',ppg*nx*ny*nz+int(ntot_p*n_avg)
!  write(6,*) ''
!-------------------------------------------
  np_i=0
  part_counter=0
! load ions in current sheets
!
 inf_loop: do
 !old  do i=1,nx*ny*nz*ppg*nsup/n_0
    np_i=np_i+1
    if (np_i .gt. maxparticles) then
      write(6,*) '***** init: particle buffer overflow *****'
      call exitallpes()
 !old    endif
 ! This is to make sure that we get the number of particles
 ! we want. We did not believe the previous version.
    elseif (np_i .ge. ppg*nx*ny*nz+int(ntot_p*n_avg)) then
    exit inf_loop
    else
 !        accept or reject particle according to local density
    call location(rvi(1,np_i),rvi(2,np_i),rvi(3,np_i))

! Find the nearest grid points for the particle.
    xx=int(rvi(1,np_i)/dx+0.5)
    yy=int(rvi(2,np_i)/dy+0.5)
    xm=rvi(1,np_i)/dx+0.5-xx; xp=1.-xm
    ym=rvi(2,np_i)/dy+0.5-yy; yp=1.-ym
! Interpolate the density perturbations to the particle position.
    npert = (np(xx  ,yy  ,1)*xp*yp + &
             np(xx+1,yy  ,1)*xm*yp + &
             np(xx  ,yy+1,1)*xp*ym + &
             np(xx+1,yy+1,1)*xm*ym ) 

    if (rand_num()*nsup .ge. n_0+npert) then
! checking the number of particles if loop
      np_i=np_i-1
    else
! generate particle thermal velocities
      call maxwellian(real(T_i,drk), real(1.,drk), &
                      rvi(4,np_i), rvi(5,np_i), rvi(6,np_i))
    endif ! end the check number of particles loop
    endif ! for the maxparticles if loop
 !old  enddo
    enddo inf_loop

    n_avg=ppg/n_0  
      call redistribute(rvi,np_i)

    do i=1,np_i
    xx=int(rvi(1,i)/dx-my_pex*nx+0.5)
    yy=int(rvi(2,i)/dy-my_pey*ny+0.5)
    xm=rvi(1,i)/dx-my_pex*nx+0.5-xx; xp=1.-xm
    ym=rvi(2,i)/dy-my_pey*ny+0.5-yy; yp=1.-ym
   
!interpolate Fvx and Fvy to particle position and add to particle's velocity
!	write(6,*) 'xm,ym,xp,yp',xm,ym,xp,yp

    vix = (fvx(xx  ,yy  ,1)*xp*yp + &
           fvx(xx+1,yy  ,1)*xm*yp + &
           fvx(xx  ,yy+1,1)*xp*ym + &
           fvx(xx+1,yy+1,1)*xm*ym )
    viy = (fvy(xx  ,yy  ,1)*xp*yp + &
           fvy(xx+1,yy  ,1)*xm*yp + &
           fvy(xx  ,yy+1,1)*xp*ym + &
           fvy(xx+1,yy+1,1)*xm*ym )
    viz = (fvz(xx  ,yy  ,1)*xp*yp + &
           fvz(xx+1,yy  ,1)*xm*yp + &
           fvz(xx  ,yy+1,1)*xp*ym + &
           fvz(xx+1,yy+1,1)*xm*ym )

     call veloadd(rvi(4,i),rvi(5,i),rvi(6,i), &
        real(vix,drk),real(viy,drk),real(viz,drk) )
     enddo

  call redistribute(rvi,np_i)

! Add the background magnetic field.
   b1x=b0x+b1x; b1y=b1y+b0y; b1z=b0z+b1z

! calculate electron pressure
    call calc_rho(rvi,np_i,real(+1.,drk),.true.)
  do z=1,nz; do y=1,ny; do x=1,nx
#ifdef barotropic
    pe1(x,y,z)=T_e*rho(x,y,z)**gam                
#else
    pe1(x,y,z)=rho(x,y,z)*T_e
#endif
  enddo; enddo; enddo 
! write start-up file
  call output(0,.true.)
End Subroutine init_Turb
